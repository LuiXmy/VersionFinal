/* Generated By:JavaCC: Do not edit this line. eg1.java */
import java.util.Vector;
import java.util.HashMap;
import java.util.LinkedList;
//A ver que sale ahora
public class eg1 implements eg1Constants {
        final static int ID = 24;
        final static int ENTERO = 27;
        final static int CADENA = 28;
        final static int FUNCION = 23;
        final static int VECTOR = 100;
        static HashMap<String, TablaSimbolos> tablas = new HashMap <String, TablaSimbolos>();
        static TablaSimbolos tablageneral = new TablaSimbolos();
        static TablaSimbolos tablaactiva = tablageneral;
        static String nombrefuncion="";
        static LinkedList<tupla_Tercetos> lista = new LinkedList() ;

        private static class BloqueCondicion{
                String etqVerdad, etqFalso;
        }

        private static void usarLabel(String label){
                System.out.println(label+":");
                Tercetos ter = new Tercetos();
            tupla_Tercetos tupla = new tupla_Tercetos(tablaactiva,ter.InsertarEtiqueta(label));
        lista.add(tupla);
        }

        private static void usarGoto(String label){
                System.out.println("\u005ctgoto "+ label);
                Tercetos ter = new Tercetos();
            tupla_Tercetos tupla = new tupla_Tercetos(tablaactiva,ter.saltoIncondicional(label));
        lista.add(tupla);
        }

        private static String OpRelacional(String e1,String e2,String op){
                String tmp = nuevaTmp();
                usarASIG(tmp, e1+op+e2);
                return tmp;
        }


//	private static BloqueCondicion usarOpRelacional(String e1,String e2,String op){
//		BloqueCondicion blq = new BloqueCondicion();
//		blq.etqVerdad = nuevaEtq();
//		blq.etqFalso = nuevaEtq();// habria que meter un temporal intermedio para gestionar e1+op+e2
//		String tmp=OpRelacional(e1,e2,op);
//		System.out.println("\tif "+ tmp +" goto "+ blq.etqVerdad);
//		usarGoto(blq.etqFalso);
//		return blq;
//	}




        private static void usarOpRelacional(BloqueCondicion blq, String op){
//		blq.etqVerdad = nuevaEtq();
                blq.etqFalso = nuevaEtq();// habria que meter un temporal intermedio para gestionar e1+op+e2
                System.out.println("\u005ctif "+ op +" goto "+ blq.etqFalso);
                Tercetos ter = new Tercetos();
            tupla_Tercetos tupla = new tupla_Tercetos(tablaactiva,ter.saltoCondicional(op,blq.etqFalso));
        lista.add(tupla);

/*		System.out.println("\tif "+ op +" goto "+ blq.etqVerdad);
		usarGoto(blq.etqFalso);
		return blq;
*/
        }

        private static void bloqueFuncion(Token t)
        {
                usarLabel(t.image);
//		System.out.println("\tFUNCION "+t.image);
        }

        private static void imprimirLlamada(String nombre, Vector< Expresion > elementos)
        {
                for (int i=elementos.size()-1; i>=0; i--)
                {
                                Expresion exp=elementos.get(i);
                                System.out.println("\u005ctparam "+ exp._str);
                }
                System.out.println("\u005ctcall "+ nombre + ", "+elementos.size());
        }





        public static void usarOpInterrog(String op, String expr1, String expr2, String nombre){
                String etiqueta1=nuevaEtq();// etqFalso
                String etiqueta2=nuevaEtq();
                System.out.println("\u005ctif "+ op +" goto "+ etiqueta1); // si no se cumple salto a etqFalso
                Tercetos ter = new Tercetos();
            tupla_Tercetos tupla = new tupla_Tercetos(tablaactiva,ter.saltoCondicional(op,etiqueta1));
        lista.add(tupla);
                usarASIG(nombre,expr1);
                usarGoto(etiqueta2);
                usarLabel(etiqueta1);
                usarASIG(nombre,expr2);
                usarLabel(etiqueta2);
        }


        private static void condicionDo(String etiq, String op){
                System.out.println("\u005ctif "+ op +" goto "+ etiq);
        }

        private static void intercambiarCondicion(BloqueCondicion blq){
                String aux = blq.etqVerdad;
                blq.etqVerdad = blq.etqFalso;
                blq.etqFalso = blq.etqVerdad;
        }

        private static int actualTmp=0, actualEtq=0;

        private static String nuevaEtq(){
                return "etq"+(++actualEtq);
        }


        private static String nuevaTmp(){
                return "tmp"+(++actualTmp);
        }

        private static void usarASIG(String s, String e){
            System.out.println("\u005ct"+s+"="+e);
            Tercetos ter = new Tercetos();
            tupla_Tercetos tupla = new tupla_Tercetos(tablaactiva,ter.asignacion(s,e));
        lista.add(tupla);
        }

        private static String usarOpUnario(String e1){
                String tmp = nuevaTmp();
                Symbol simbolo = new Symbol(tmp, 1234, ENTERO, 1);  // Tamaño incrustado
                tablaactiva.insertarTS(tmp,simbolo);
                System.out.println("\u005ct"+tmp+"="+e1);
                Tercetos ter = new Tercetos();
        tupla_Tercetos tupla = new tupla_Tercetos(tablaactiva,ter.asignacion_valor(tmp,Integer.parseInt(e1)));
        lista.add(tupla);
                return tmp;
        }


        private static String usarOpAritmetico(String e1, String e2, String op){
                String tmp = nuevaTmp();
                Symbol simbolo = new Symbol(tmp, 1234, ENTERO,1);  // Tamaño incrustado
                tablaactiva.insertarTS(tmp,simbolo);
                System.out.println("\u005ct"+tmp+"="+e1+op+e2);
                Tercetos ter = new Tercetos();
                tupla_Tercetos tupla = new tupla_Tercetos(tablaactiva,ter.operacionBinaria(e1,e2,op,tmp));
                lista.add(tupla);
                return tmp;
        }


        private static String usarOpRel(String e1, String e2, String op){
                String tmp = nuevaTmp();
                Symbol simbolo = new Symbol(tmp, 1234, ENTERO,1);  // Tamaño incrustado
                tablaactiva.insertarTS(tmp,simbolo);
                System.out.println("\u005ct"+tmp+"="+e1+op+e2);
                Tercetos ter = new Tercetos();
                tupla_Tercetos tupla = new tupla_Tercetos(tablaactiva,ter.opRelacional(e1,e2,tmp));
                lista.add(tupla);
                return tmp;
        }


        private static String usarOpLogico(String e1, String e2, String op){
                String tmp = nuevaTmp();
                Symbol simbolo = new Symbol(tmp, 1234, ENTERO,1);  // Tamaño incrustado
                tablaactiva.insertarTS(tmp,simbolo);
                System.out.println("\u005ct"+tmp+"="+e1+op+e2);
                Tercetos ter = new Tercetos();
                tupla_Tercetos tupla = new tupla_Tercetos(tablaactiva,ter.opLogico(e1,e2,tmp));
                lista.add(tupla);
                return tmp;
        }


        private static String operarVectorPrompt(String tmp, String nombreVector){
                String tmp2 = nuevaTmp();
                Symbol simbolo = new Symbol(tmp2, 1234, ENTERO);
                tablaactiva.insertarTS(tmp2,simbolo);
                System.out.println("\u005ct"+tmp2+"="+nombreVector+"["+tmp+"]");
                return tmp2;
        }


        private static void copiarVectorEnOtro(Symbol tmp, Symbol tmp2)
        {
                for(int i=0; i<tmp.numeroelementos; i++)
                {
                        System.out.println("\u005ct"+tmp.key+"["+i+"]"+" = "+ tmp2.key+"["+i+"] ");
                }
        }

        private static void asignacionVector(String id, int tamano, String exp, String exp1)
        {
                String etiq = nuevaEtq();
                System.out.println("\u005ctif "+exp+" > " +tamano);
                System.out.println("\u005ctgoto "+etiq);
                System.out.println("\u005ct"+id+"["+exp+"]"+" = "+exp1);
                usarLabel(etiq);
        }



        private static boolean existeEnAlgunaTS(String clave)
        {
                if(!tablaactiva.existeClave(clave) && !tablageneral.existeClave(clave))
                        return false;
                else
                        return true;
        }

        public static void main(String args []) throws ParseException
        {

            eg1 parser;// = new eg1(System.in);
                if(args.length == 0){// ejecucion sin argumentos
                System.out.println ("ExampleParser: Leyendo de la entrada estandar ...");
                parser = new eg1(System.in);
        }else if(args.length == 1){// ejecucion con fichero de entrada
                System.out.println ("ExampleParser: Leyendo el fichero " + args[0]);
                tablas.put("general",tablageneral);
                try {
                parser = new eg1(new java.io.FileInputStream(args[0]));
                }
                catch(java.io.FileNotFoundException e) {
                System.out.println ("ExampleParser: El fichero " + args[0] + " no ha sido encontrado.");
                return;
                }
        }else {// en otro caso
                System.out.println ("ExampleParser:  Debes utilizarlo de una de las siguientes formas:");
                System.out.println ("         java ExampleParser < fichero");
                System.out.println ("Or");
                System.out.println ("         java ExampleParser fichero");
                return;
        }
        //  String linea;
        boolean cond = true;
        while (cond)
        {
        if (args.length == 1)
                        System.out.println("Leyendo linea");
        else
              {
                        System.out.println("Leyendo de teclado...");
                        System.out.print("Enter an expression like \u005c"1+(2+3)*4;\u005c" :");
             }
              try
              {
                switch (eg1.one_line())
                {
                  case -1 :
                  System.out.println("Fin fichero"); // fin fichero
                  cond = false;
                  break;
                  case 0 :
                  System.out.println("OK.");
                  break;
                  case 1 :
                  System.out.println("OK. Funcion");
                  break;
                  case 2 :
                  System.out.println("Ok. Sentencia");
                  break;
                  default :
                  break;
                }
              }
              catch (Exception e)
              {
                System.out.println("NOK.");
                System.out.println(e.getMessage());
                eg1.ReInit(System.in);
              }
              catch (Error e)
              {
                System.out.println("Oops.");
                System.out.println(e.getMessage());
                break;
              }
            }
            System.out.println(lista.size());
            tablageneral.imprimir();
                GenCodFinal codFinal = new GenCodFinal(lista,tablageneral,"ensamblador.ens");
         }

//////////////
  static final public int one_line() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FUNCTION:
      Funcion();
                {if (true) return 1;}
      break;
    case DO:
    case IF:
    case VAR:
    case RETURN:
    case PROMPT:
    case DOCUMENT:
    case IDENTIFICADOR:
      Sentencia();
                {if (true) return 2;}
      break;
    case 0:
      jj_consume_token(0);
                {if (true) return -1;}
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public void Sentencia() throws ParseException {
    if (jj_2_1(2)) {
      VariableDeclarator();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IF:
        IfStatement();
        break;
      case DO:
        DoStatement();
        break;
      case RETURN:
        ReturnStatement();
        break;
      case PROMPT:
        PromptStatement();
        break;
      case DOCUMENT:
        DocumentStatement();
        break;
      default:
        jj_la1[1] = jj_gen;
        if (jj_2_2(2)) {
          FunctionStatement();
        } else if (jj_2_3(3)) {
          VectorStatement();
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENTIFICADOR:
            VectorAssignamentStatement();
            break;
          default:
            jj_la1[2] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    }
  }

  static final public void VectorStatement() throws ParseException {
        Expresion exp=null;
        Expresion exp1=null;
        Token id;
        Symbol simbolo=null;
    id = jj_consume_token(IDENTIFICADOR);
    jj_consume_token(CORCHETEDRCHA);
    exp = Expresion(id.image);
    jj_consume_token(CORCHETEIZQ);
    jj_consume_token(ASIGNACION);
    exp1 = Expresion("");
                simbolo=tablaactiva.obtenerSimbolo(id.image);
                if (simbolo==null)
                {
                        simbolo=tablageneral.obtenerSimbolo(id.image);
                        if(simbolo==null)
                                {if (true) throw new Error("El Vector tiene que estar declarado previamente");}
                }
                if (simbolo.tipo!=VECTOR)
                {
                        {if (true) throw new Error("El tipo del elemento izquierdo de la asignacion tiene que ser un vector");}
                }
                if (exp._tipo!=ENTERO)
                {
                        if (tablaactiva.tipo(exp._str)!=ENTERO) //Aqui es un ID
                        {
                                if (tablageneral.tipo(exp._str)!=ENTERO)
                                {
                                        {if (true) throw new Error("El tipo del indice del Vector debe ser un entero");}
                                }
                        }
                }
                if ((tablaactiva.existeClave(id.image) && tablaactiva.tipo(id.image)==VECTOR) ||
                (tablageneral.existeClave(id.image) && tablageneral.tipo(id.image)==VECTOR))
                {
                        asignacionVector(simbolo.key, simbolo.numeroelementos, exp._str, exp1._str);
                }else
                        {if (true) throw new Error("El Vector en linea "+id.beginLine+" no existe");}
  }

  static final public void VectorAssignamentStatement() throws ParseException {
        Token t=null;
        Token t2=null;
        Symbol aux=null;
        Symbol aux2=null;
    t = jj_consume_token(IDENTIFICADOR);
    jj_consume_token(CORCHETEDRCHA);
    jj_consume_token(CORCHETEIZQ);
    jj_consume_token(ASIGNACION);
    t2 = jj_consume_token(IDENTIFICADOR);
    jj_consume_token(CORCHETEDRCHA);
    jj_consume_token(CORCHETEIZQ);
                if(!existeEnAlgunaTS(t.image))
                {
                        {if (true) throw new Error("El vector izquierdo tiene que declararse antes de usarse");}
                }
                if(!existeEnAlgunaTS(t2.image))
                {
                        {if (true) throw new Error("El vector derecho tiene que declararse antes de usarse");}
                }
                if((tablaactiva.tipo(t.image)!=VECTOR || tablaactiva.tipo(t2.image)!=VECTOR))
                {
                        {if (true) throw new Error("El tipo de los dos operandos tiene que ser Vector");}
                }
                if((tablageneral.tipo(t.image)!=VECTOR || tablageneral.tipo(t2.image)!=VECTOR))
                {
                        {if (true) throw new Error("El tipo de los dos operandos tiene que ser Vector");}
                }
                aux=tablaactiva.obtenerSimbolo(t.image);
                aux2=tablaactiva.obtenerSimbolo(t2.image);
                if(aux==null)
                {
                        tablageneral.obtenerSimbolo(t.image);
                }
                if(aux2==null)
                {
                        tablageneral.obtenerSimbolo(t2.image);
                }
                if(aux.numeroelementos!=aux2.numeroelementos)
                {
                        {if (true) throw new Error("El tama\u00f1o de los dos vectores tiene que ser el mismo");}
                }
                copiarVectorEnOtro(aux, aux2);
  }

  static final public void FunctionStatement() throws ParseException {
        Token tok;
        Vector< Expresion > elementos=null;
        Vector< Symbol > vdecl=null;
        Symbol declfun=null;
    tok = jj_consume_token(IDENTIFICADOR);
    elementos = LlamadaFuncion(tok);
                declfun=tablageneral.obtenerSimbolo(tok.image);
                vdecl=declfun.vArgumentos;
                for (int i=0; i<vdecl.size(); i++)
                {
                        Expresion aux=elementos.get(i);
                        if (vdecl.get(i).tipo != tablaactiva.obtenerSimbolo(aux._str).tipo)
                                {if (true) throw new Error("El tipo de los parametros de llamada no coincide con los de la declaracion");}
                }
                imprimirLlamada(tok.image,elementos);
  }

  static final public void IfStatement() throws ParseException {
        Expresion expr = null;
        String etqFinIf = "";
        BloqueCondicion blq = new BloqueCondicion();
    jj_consume_token(IF);
    expr = Expresion("");
                                                                        usarOpRelacional(blq, expr._str);
                                                                //usarLabel(blq.etqVerdad);

    Sentencia();
                                                                        usarLabel(blq.etqFalso);
  }

  static final public void DoStatement() throws ParseException {
        Expresion expr=null;
        String etq=null;
        BloqueCondicion blq = new BloqueCondicion();
    jj_consume_token(DO);
    jj_consume_token(LLAVEDRCHA);
                etq=nuevaEtq();
                usarLabel(etq);
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DO:
      case IF:
      case VAR:
      case RETURN:
      case PROMPT:
      case DOCUMENT:
      case IDENTIFICADOR:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_1;
      }
      Sentencia();
    }
    jj_consume_token(LLAVEIZQ);
    jj_consume_token(WHILE);
    expr = Expresion("");
                condicionDo(etq,expr._str);
  }

  static final public void ReturnStatement() throws ParseException {
                Expresion exp=null;
    jj_consume_token(RETURN);
    if (jj_2_4(2)) {
      exp = Expresion("");
                System.out.println(exp);
    } else {
      ;
    }
                System.out.println("RET");
  }

// prompt solo lee numeros del teclado, si se mete un caracter habria que lanzar un error en el tiempo de ejecucion, no se si eso podemos hacerlo
  static final public void PromptStatement() throws ParseException {
        Token t=null;
        boolean esVector = false;
        Symbol simbolo=null;
    jj_consume_token(PROMPT);
    jj_consume_token(PARENDRCHA);
    t = jj_consume_token(IDENTIFICADOR);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CORCHETEDRCHA:
      esVector = PromptVector(esVector, t.image);
          if (esVector)//Si estamos en el ambito general, error
          {
                if (!tablaactiva.existeClave(t.image) || tablaactiva.tipo(t.image)!=VECTOR) // compruebo primero si existe ID en TS activa. no hace falta comprobar si tablaactiva==tablageneral
                        {
                                if (!tablageneral.existeClave(t.image) || tablaactiva.tipo(t.image)!=VECTOR) // compruebo despues si existe ID en TS general. si no existe se agrega a TS general
                                {
                        {if (true) throw new Error("Error. El identificador de vector no ha sido declarado previamente o no es el tipo correcto, linea: "+t.beginLine);}
                                }
                        }
          }
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
                        if (!tablaactiva.existeClave(t.image)) // compruebo primero si existe ID en TS activa. no hace falta comprobar si tablaactiva==tablageneral
                        {
                                if (!tablageneral.existeClave(t.image)) // compruebo despues si existe ID en TS general. si no existe se agrega a TS general
                                {
                        simbolo=new Symbol(t.image, t.beginLine, ENTERO); // agrego nuevo simbolo a TS general
                        tablageneral.insertarTS(t.image, simbolo);
                                }
                        }
    jj_consume_token(PARENIZQ);
  }

// esto hay que mirarlo con cuidado es como las expresiones, habra que crear clase JSPromptAditiveExpresion y JSPromptVector
  static final public boolean PromptVector(boolean esVector,String nombreVector) throws ParseException {
        Expresion res;
    jj_consume_token(CORCHETEDRCHA);
                esVector=true;
    res = PromptAditiveExpresion();
    jj_consume_token(CORCHETEIZQ);
                operarVectorPrompt(res._str, nombreVector);
                {if (true) return esVector;}
    throw new Error("Missing return statement in function");
  }

  static final public Expresion PromptAditiveExpresion() throws ParseException {
  Expresion st1 = null;
  Expresion st2 = null;
    // aqui dentro hay que comprobar los token, si es identificador tiene que existir en TS (primero comprobar tabla activa y luego general)
     // si no existe en ninguna TS generar error.
     // mas adelante habrá que comprobar si el indice del vector se encuentra dentro del rango del vector etc, etc.
     // para hacer las comprobaciones de los distintos tipos de Token usar t.kind, un integer es 27 y un identificador 24
            st1 = PromptPrimaryExpression();
                if (st1._tipo == ID && !tablaactiva.existeClave(st1._str)) // compruebo primero si existe ID en TS activa. no hace falta comprobar si tablaactiva==tablageneral
                {
                        if (!tablageneral.existeClave(st1._str)) // compruebo despues si existe ID en TS general. si no existe se agrega a TS general
                        {
                                {if (true) throw new Error("Error. La variable "+st1._str+" en la linea "+st1._linea+" no ha sido declarada previamente.");}
                        }
                }// si el token es identificador, habra que poner el tipo del simbolo a ENTERO, si es de otro tipo se cambia y si es entero tb
//aqui habrá que hacer algo si el token es un numero

    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MAS:
      jj_consume_token(MAS);
      st2 = PromptPrimaryExpression();
                if (st2._tipo == ID && !tablaactiva.existeClave(st2._str)) // compruebo primero si existe ID en TS activa. no hace falta comprobar si tablaactiva==tablageneral
                {
                         if (!tablageneral.existeClave(st2._str)) // compruebo despues si existe ID en TS general. si no existe se agrega a TS general
                        {
                        {if (true) throw new Error("Error. La variable "+st2._str+" en la linea "+st2._linea+" no ha sido declarada previamente.");}
                        }
                }
                if(st1._tipo==ENTERO && st2._tipo==ENTERO)
                {
                        st1._str = usarOpAritmetico(st1._str, st2._str, "+");
                }else if(tablaactiva.tipo(st1._str)==ENTERO && tablaactiva.tipo(st2._str)==ENTERO)
                {
                        st1._str = usarOpAritmetico(st1._str, st2._str, "+");
                }else
                {
                        {if (true) throw new Error("El tipo de las expresiones no es correcto");}
                }
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
                        {if (true) return st1;}
    throw new Error("Missing return statement in function");
  }

  static final public Expresion PromptPrimaryExpression() throws ParseException {
        Token t = null;
        Expresion st = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFICADOR:
      t = jj_consume_token(IDENTIFICADOR);
        st = new Expresion(t.image, t.kind, t.beginLine);
                st.t = t;
      break;
    case INTEGER_LITERAL:
      t = jj_consume_token(INTEGER_LITERAL);
        st = new Expresion(usarOpAritmetico(token.image, "", ""), t.kind, t.beginLine);
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return st;}
    throw new Error("Missing return statement in function");
  }

  static final public void DocumentStatement() throws ParseException {
        Expresion expr=null;
    jj_consume_token(DOCUMENT);
    jj_consume_token(PUNTO);
    jj_consume_token(WRITE);
    jj_consume_token(PARENDRCHA);
    expr = Expresion("");
    jj_consume_token(PARENIZQ);
                System.out.println("\u005ctimprime "+ expr._str);
  }

  static final public void Funcion() throws ParseException {
        Token t=null;
        Vector< Symbol > vectorSimbolos=null;
        Symbol simbolo=null;
        int numeroParametros=0;
    jj_consume_token(FUNCTION);
    t = jj_consume_token(IDENTIFICADOR);
                nombrefuncion=t.image;
                if(tablageneral.existeClave(t.image))
                {
                        {if (true) throw new Error("Error en la linea "+t.beginLine+": Identificador de funcion ya declarado");}
                }else
                {
                        simbolo=new Symbol(t.image, t.beginLine, FUNCION );
                }
                bloqueFuncion(t);
    jj_consume_token(PARENDRCHA);
                tablaactiva = new TablaSimbolos(tablageneral);
                tablas.put(nombrefuncion, tablaactiva);
                //No hace falta comparar si ya estaba el nombre de la funcion en la lista de tablas
                //porque lo contemplo antes

    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFICADOR:
      vectorSimbolos = ParameterList();
                numeroParametros=vectorSimbolos.size();
      break;
    default:
      jj_la1[7] = jj_gen;
      ;
    }
    jj_consume_token(PARENIZQ);
        simbolo.numArgumentos=numeroParametros;
        simbolo.vArgumentos=vectorSimbolos;
        tablageneral.insertarTS(t.image, simbolo);
    CompoundStatement();
                System.out.println("La tabla de la funcion tiene: ");
                //tablaactiva.imprimir();
                //tablageneral.imprimir();
                tablaactiva = tablas.get("general");
  }

  static final public Vector ParameterList() throws ParseException {
        Vector< Symbol > v = new Vector < Symbol >();
        Symbol simbolo = null;
        boolean esVector=false;
        Token parametro;
    parametro = jj_consume_token(IDENTIFICADOR);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CORCHETEDRCHA:
      jj_consume_token(CORCHETEDRCHA);
      jj_consume_token(CORCHETEIZQ);
     //Tenemos un vector
        esVector=true;
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
        if(esVector)
        {
                simbolo = new Symbol(parametro.image, parametro.beginLine, VECTOR);//He metido el tipo 100 como vector
                tablaactiva.insertarTS(parametro.image,simbolo);
                v.add(simbolo);
        }else
        {
                simbolo = new Symbol(parametro.image, parametro.beginLine, ENTERO);
                        tablaactiva.insertarTS(parametro.image,simbolo);
                        v.add(simbolo);
        }
        esVector=false;
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMA:
        ;
        break;
      default:
        jj_la1[9] = jj_gen;
        break label_2;
      }
      jj_consume_token(COMA);
      parametro = jj_consume_token(IDENTIFICADOR);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CORCHETEDRCHA:
        jj_consume_token(CORCHETEDRCHA);
        jj_consume_token(CORCHETEIZQ);
        esVector=true;
        break;
      default:
        jj_la1[10] = jj_gen;
        ;
      }
        if(esVector)
        {
                simbolo = new Symbol(parametro.image, parametro.beginLine, VECTOR);
                tablaactiva.insertarTS(parametro.image,simbolo);
                v.add(simbolo);
        }else
        {
                simbolo = new Symbol(parametro.image, parametro.beginLine, ENTERO);
                        tablaactiva.insertarTS(parametro.image,simbolo);
                        v.add(simbolo);
        }
        esVector=false;
    }
                {if (true) return v;}
    throw new Error("Missing return statement in function");
  }

  static final public void CompoundStatement() throws ParseException {
    jj_consume_token(LLAVEDRCHA);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DO:
      case IF:
      case VAR:
      case RETURN:
      case PROMPT:
      case DOCUMENT:
      case IDENTIFICADOR:
        ;
        break;
      default:
        jj_la1[11] = jj_gen;
        break label_3;
      }
      Sentencia();
    }
    jj_consume_token(LLAVEIZQ);
  }

//este hace las asignaciones
  static final public void VariableDeclarator() throws ParseException {
        Token t = null;
        Expresion expr = null;
        Symbol simbolo=null;
        Token elementos =null;
        int num;
    if (jj_2_5(4)) {
      jj_consume_token(VAR);
      t = jj_consume_token(IDENTIFICADOR);
      jj_consume_token(ASIGNACION);
      jj_consume_token(NEW);
      jj_consume_token(ARRAY);
      jj_consume_token(PARENDRCHA);
      elementos = jj_consume_token(INTEGER_LITERAL);
      jj_consume_token(PARENIZQ);
                num=Integer.parseInt(elementos.image);
//			}catch (java.lang.NumberFormatException exc){
//				throw new Error("El Indice del Vector declarado en la linea "+t.beginLine+" tiene que ser un entero");
//			}
                        if (num<=0)
                        {
                                {if (true) throw new Error("El numero de elementos del Vector declarado en linea "+t.beginLine+" tiene que ser mayor que cero");}
                        }
                        //Symbol(String key, int numerolinea, int tipo, int tamano, int numeroelementos) {
                simbolo = new Symbol(t.image, t.beginLine, VECTOR, num*4, num);

                simbolo.numeroelementos=num;
                tablaactiva.insertarTS(t.image, simbolo);
                //tablaactiva.imprimir();

    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VAR:
        jj_consume_token(VAR);
        t = jj_consume_token(IDENTIFICADOR);
                simbolo=new Symbol(t.image, t.beginLine, ENTERO);
                tablaactiva.insertarTS(t.image, simbolo);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ASIGNACION:
          jj_consume_token(ASIGNACION);
          expr = Expresion(t.image);
                        usarASIG(t.image, expr._str);
          break;
        default:
          jj_la1[12] = jj_gen;
          ;
        }
        break;
      case IDENTIFICADOR:
        t = jj_consume_token(IDENTIFICADOR);
                                         // no estabamos metiendo este identificador en la TS
                                        // creo que habria que mirar primero si está en la tabla, si no no se inserta, seguramente haya que com
                                                if(!existeEnAlgunaTS(t.image))
                                                {
                                                        simbolo=new Symbol(t.image, t.beginLine, ENTERO);
                                                tablaactiva.insertarTS(t.image, simbolo);
                                        }
        jj_consume_token(ASIGNACION);
        expr = Expresion(t.image);
                                if(expr._str!="")
                                {

                                        if (!tablaactiva.buscar(t.image) && !tablageneral.buscar(t.image))
                                        {
                                                simbolo = new Symbol(t.image, t.beginLine, ENTERO);
                                                tablageneral.insertarTS(t.image, simbolo);
                                }
                                //Esto hay que arreglarlo
                                System.out.println("\u005ct"+t.image+"="+expr._str+"; asignacionVariable");
                                usarASIG(t.image,expr._str);
                                }
        break;
      default:
        jj_la1[13] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  static final public Expresion Expresion(String variable) throws ParseException {
        Expresion expr=null;
        Expresion expr2=null;
        Expresion expr3=null;
        Expresion expr4=null;
        BloqueCondicion blq=new BloqueCondicion();
    expr = ExpresionAND();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTERROGANTE:
      jj_consume_token(INTERROGANTE);
      expr2 = Expresion("");
      jj_consume_token(DOSPUNTOS);
      expr3 = Expresion("");
                usarOpInterrog(expr._str,expr2._str,expr3._str, variable);
                expr4=new Expresion("",ENTERO);
                {if (true) return expr4;}
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
       {if (true) return expr;}
    throw new Error("Missing return statement in function");
  }

  static final public Expresion ExpresionAND() throws ParseException {
        Expresion expr1 = null;
        Expresion expr2 = null;
    expr1 = RelationalExpression();
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        ;
        break;
      default:
        jj_la1[15] = jj_gen;
        break label_4;
      }
      jj_consume_token(AND);
      expr2 = RelationalExpression();
                                                                                                                        expr1._str = usarOpLogico(expr1._str, expr2._str, "&&");
    }
        {if (true) return expr1;}
    throw new Error("Missing return statement in function");
  }

  static final public Expresion RelationalExpression() throws ParseException {
        boolean expr1TablaActiva = false;
        boolean expr2TablaActiva = false;
        boolean expr1TablaGeneral = false;
        boolean expr2TablaGeneral = false;
        Expresion expr1 = null;
        Expresion expr2 = null;
        Expresion exprCond = null;
        BloqueCondicion blqCond;
    //revisar, en la version de luis hay JSRelacional(t, expr1, expr2);  pero expr1 no se le ha asignado ningún valor
      expr1 = AdditiveExpression();
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MENOR:
        ;
        break;
      default:
        jj_la1[16] = jj_gen;
        break label_5;
      }
      jj_consume_token(MENOR);
      expr2 = AdditiveExpression();
                if(tablaactiva.tipo(expr1._str)!=-1)
                        expr1TablaActiva = true;
                else if(tablageneral.tipo(expr1._str)!=-1)
                        expr1TablaGeneral = true;
                if(tablaactiva.tipo(expr2._str)!=-1)
                        expr2TablaActiva = true;
                else if(tablageneral.tipo(expr2._str)!=-1)
                        expr2TablaGeneral = true;

                if(expr1._tipo==ENTERO && expr2._tipo==ENTERO)
                {
                        expr1._str = usarOpAritmetico(expr1._str, expr2._str, "<");
                }else if((tablaactiva.tipo(expr1._str)==ENTERO&&expr1TablaActiva) &&
                         (tablaactiva.tipo(expr2._str)==ENTERO&&expr2TablaActiva))
                {
                        expr1._str = usarOpAritmetico(expr1._str, expr2._str, "<");
                }else if((tablageneral.tipo(expr1._str)==ENTERO&&expr1TablaGeneral) &&
                         (tablaactiva.tipo(expr2._str)==ENTERO&&expr2TablaActiva))
                {
                        expr1._str = usarOpAritmetico(expr1._str, expr2._str, "<");
                }else if((tablaactiva.tipo(expr1._str)==ENTERO&&expr1TablaActiva) &&
                         (tablageneral.tipo(expr2._str)==ENTERO&&expr2TablaGeneral))
                {
                        expr1._str = usarOpAritmetico(expr1._str, expr2._str, "<");
                }else if((tablageneral.tipo(expr1._str)==ENTERO&&expr1TablaGeneral) &&
                         (tablageneral.tipo(expr2._str)==ENTERO&&expr2TablaGeneral))
                {
                        expr1._str = usarOpAritmetico(expr1._str, expr2._str, "<");
                }else
                {
                        {if (true) throw new Error("El tipo de las expresiones no es correcto");}
                }
    }
      {if (true) return expr1;}
    throw new Error("Missing return statement in function");
  }

  static final public Expresion AdditiveExpression() throws ParseException {
        boolean expr1TablaActiva = false;
        boolean expr2TablaActiva = false;
        boolean expr1TablaGeneral = false;
        boolean expr2TablaGeneral = false;
        Expresion expr1 = null;
        Expresion expr2 = null;
        String st1 = "";
        String st2 = "";
    expr1 = VectorExpression();
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MAS:
      case MENOS:
        ;
        break;
      default:
        jj_la1[17] = jj_gen;
        break label_6;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MAS:
        jj_consume_token(MAS);
        expr2 = VectorExpression();
                if(tablaactiva.tipo(expr1._str)!=-1)
                        expr1TablaActiva = true;
                else if(tablageneral.tipo(expr1._str)!=-1)
                        expr1TablaGeneral = true;
                if(tablaactiva.tipo(expr2._str)!=-1)
                        expr2TablaActiva = true;
                else if(tablageneral.tipo(expr2._str)!=-1)
                        expr2TablaGeneral = true;

                if(expr1._tipo==ENTERO && expr2._tipo==ENTERO)
                {
                        expr1._str = usarOpAritmetico(expr1._str, expr2._str, "+");
                }else if((tablaactiva.tipo(expr1._str)==ENTERO&&expr1TablaActiva) &&
                         (tablaactiva.tipo(expr2._str)==ENTERO&&expr2TablaActiva))
                {
                        expr1._str = usarOpAritmetico(expr1._str, expr2._str, "+");
                }else if((tablageneral.tipo(expr1._str)==ENTERO&&expr1TablaGeneral) &&
                         (tablaactiva.tipo(expr2._str)==ENTERO&&expr2TablaActiva))
                {
                        expr1._str = usarOpAritmetico(expr1._str, expr2._str, "+");
                }else if((tablaactiva.tipo(expr1._str)==ENTERO&&expr1TablaActiva) &&
                         (tablageneral.tipo(expr2._str)==ENTERO&&expr2TablaGeneral))
                {
                        expr1._str = usarOpAritmetico(expr1._str, expr2._str, "+");
                }else if((tablageneral.tipo(expr1._str)==ENTERO&&expr1TablaGeneral) &&
                         (tablageneral.tipo(expr2._str)==ENTERO&&expr2TablaGeneral))
                {
                        expr1._str = usarOpAritmetico(expr1._str, expr2._str, "+");
                }else
                {
                        {if (true) throw new Error("El tipo de las expresiones no es correcto");}
                }
        break;
      case MENOS:
        jj_consume_token(MENOS);
        expr2 = VectorExpression();
                if(tablaactiva.tipo(expr1._str)!=-1)
                        expr1TablaActiva = true;
                else if(tablageneral.tipo(expr1._str)!=-1)
                        expr1TablaGeneral = true;
                if(tablaactiva.tipo(expr2._str)!=-1)
                        expr2TablaActiva = true;
                else if(tablageneral.tipo(expr2._str)!=-1)
                        expr2TablaGeneral = true;

                if(expr1._tipo==ENTERO && expr2._tipo==ENTERO)
                {
                        expr1._str = usarOpAritmetico(expr1._str, expr2._str, "-");
                }else if((tablaactiva.tipo(expr1._str)==ENTERO&&expr1TablaActiva) &&
                         (tablaactiva.tipo(expr2._str)==ENTERO&&expr2TablaActiva))
                {
                        expr1._str = usarOpAritmetico(expr1._str, expr2._str, "-");
                }else if((tablageneral.tipo(expr1._str)==ENTERO&&expr1TablaGeneral) &&
                         (tablaactiva.tipo(expr2._str)==ENTERO&&expr2TablaActiva))
                {
                        expr1._str = usarOpAritmetico(expr1._str, expr2._str, "-");
                }else if((tablaactiva.tipo(expr1._str)==ENTERO&&expr1TablaActiva) &&
                         (tablageneral.tipo(expr2._str)==ENTERO&&expr2TablaGeneral))
                {
                        expr1._str = usarOpAritmetico(expr1._str, expr2._str, "-");
                }else if((tablageneral.tipo(expr1._str)==ENTERO&&expr1TablaGeneral) &&
                         (tablageneral.tipo(expr2._str)==ENTERO&&expr2TablaGeneral))
                {
                        expr1._str = usarOpAritmetico(expr1._str, expr2._str, "-");
                }else
                {
                        {if (true) throw new Error("El tipo de las expresiones no es correcto");}
                }
        break;
      default:
        jj_la1[18] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
        {if (true) return expr1;}
    throw new Error("Missing return statement in function");
  }

  static final public Expresion VectorExpression() throws ParseException {
        Expresion expr = null;
        Expresion expr2 = null;
        Symbol simbolo=null;
        Token t=null;
    expr = FunctionExpression();
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CORCHETEDRCHA:
        ;
        break;
      default:
        jj_la1[19] = jj_gen;
        break label_7;
      }
      t = jj_consume_token(CORCHETEDRCHA);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFICADOR:
      case INTEGER_LITERAL:
      case STRING_LITERAL:
      case PARENDRCHA:
        expr2 = Expresion("");
        break;
      default:
        jj_la1[20] = jj_gen;
        ;
      }
      jj_consume_token(CORCHETEIZQ);
                String tmp=nuevaTmp();
                if(expr2!=null)
                {
                        System.out.println("\u005ct"+tmp+" = "+expr._str+ "[ "+expr2._str+" ]");
                        simbolo=new Symbol(tmp, t.beginLine, ENTERO);
                        tablaactiva.insertarTS(tmp,simbolo);
                        Expresion resultado = new Expresion(tmp, ENTERO);
                        {if (true) return  resultado;}
                }
    }
                {if (true) return expr;}
    throw new Error("Missing return statement in function");
  }

  static final public Expresion FunctionExpression() throws ParseException {
  Expresion expr = null;
  Vector< Expresion > v;
  Vector< Symbol > vdecl;
  Symbol declfun=null;
    expr = PrimaryExpression();
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PARENDRCHA:
        ;
        break;
      default:
        jj_la1[21] = jj_gen;
        break label_8;
      }
      v = LlamadaFuncion(expr.t);
                declfun=tablageneral.obtenerSimbolo(expr.t.image);
                vdecl=declfun.vArgumentos;
                for (int i=0; i<vdecl.size(); i++)
                {
                        Expresion aux=v.get(i);
                        if (vdecl.get(i).tipo != tablaactiva.obtenerSimbolo(aux._str).tipo)
                                {if (true) throw new Error("El tipo de los parametros de llamada no coincide con los de la declaracion");}
                }
                imprimirLlamada(expr._str,v);
                {if (true) return expr;}
    }
                {if (true) return expr;}
    throw new Error("Missing return statement in function");
  }

  static final public Vector LlamadaFuncion(Token nombre) throws ParseException {
        Vector v = null;
    jj_consume_token(PARENDRCHA);
                                //tablageneral.imprimir();
                                if ((nombre.kind==ID) && (tablageneral.tipo(nombre.image) != FUNCION))
                                        {if (true) throw new Error("La funcion no esta declarada anteriormente");}
    //Meter aqui lo que viene de llamadafuncion()
    
       v = ArgumentList(nombre);
    jj_consume_token(PARENIZQ);
                {if (true) return v;}
    throw new Error("Missing return statement in function");
  }

  static final public Vector ArgumentList(Token nombre) throws ParseException {
        Token t=null;
        Expresion expr1=null;
        Expresion expr2=null;
        Vector< Expresion >v = null;
        Symbol temp=null;

    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFICADOR:
    case INTEGER_LITERAL:
    case STRING_LITERAL:
    case PARENDRCHA:
      expr1 = Expresion("");
                v=new Vector < Expresion >();

                if (existeEnAlgunaTS(expr1._str))
                {
                        v.add(expr1);
                }else
                {
                        {if (true) throw new Error("Error en linea: "+nombre.beginLine+", Los parametros tienen que ser declarados antes de usarlos");}
                }
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMA:
          ;
          break;
        default:
          jj_la1[22] = jj_gen;
          break label_9;
        }
        jj_consume_token(COMA);
        expr2 = Expresion("");
                if(existeEnAlgunaTS(expr1._str))
                {
                        v.add(expr2);
                }else
                {
                        {if (true) throw new Error("Error en linea: "+nombre.beginLine+" Los parametros tienen que ser declarados antes de usarlos");}
                }
      }
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
                temp = tablageneral.obtenerSimbolo(nombre.image);
                if(v==null && temp.numArgumentos == 0)
                {
                        {if (true) return null;}
                }
                if(v==null)
                {
                                v=new Vector < Expresion >();
                }
                if(temp.numArgumentos!=v.size())
                {
                        {if (true) throw new Error("Numero de argumentos de la llamada a funcion en "+nombre.beginLine+" no coincide con los de la declaraci\u00f3n");}

                }
                else
                    {if (true) return v;}
    throw new Error("Missing return statement in function");
  }

  static final public Expresion PrimaryExpression() throws ParseException {
 Token t = null;
 Expresion st = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PARENDRCHA:
      jj_consume_token(PARENDRCHA);
      st = Expresion("");
      jj_consume_token(PARENIZQ);
      break;
    case IDENTIFICADOR:
      t = jj_consume_token(IDENTIFICADOR);
                        st = new Expresion(t.image, t.kind);
                                                        st.t = t;
      break;
    case INTEGER_LITERAL:
      //  t = <INTEGER_LITERAL> {st = new Expresion(usarOpAritmetico(token.image, "", ""), t.kind); }
         t = jj_consume_token(INTEGER_LITERAL);
                          st = new Expresion(usarOpUnario(token.image), t.kind);

                if(Integer.parseInt(token.image) > 32767)
                {
                                // al no usar operador unario no comprobamos limite inferior || Integer.parseInt(token.image) < -32768)
                        {if (true) throw new Error ("El numero esta fuera del rango de la maquina [-32768..32767]");}
                }
                {if (true) return st;}
      break;
    case STRING_LITERAL:
      t = jj_consume_token(STRING_LITERAL);
                String cadena = t.image.substring(1, t.image.length()-1);
                try{
                                int feo=Integer.parseInt(cadena);
                                st = new Expresion(usarOpAritmetico(cadena, "", ""), ENTERO);
                                {if (true) return st;}
                        }catch (java.lang.NumberFormatException exc){
                                //throw new Error("El String a transformar tiene que ser un entero");
                        }
                st = new Expresion(cadena, t.kind);
                st.t = t;
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  {if (true) return st;}
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  static private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  static private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  static private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  static private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  static private boolean jj_3R_22() {
    if (jj_scan_token(MENOR)) return true;
    return false;
  }

  static private boolean jj_3R_34() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  static private boolean jj_3R_13() {
    if (jj_3R_17()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_18()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_23() {
    if (jj_3R_25()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_26()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_28() {
    if (jj_scan_token(MENOS)) return true;
    return false;
  }

  static private boolean jj_3R_16() {
    if (jj_scan_token(PARENDRCHA)) return true;
    return false;
  }

  static private boolean jj_3_3() {
    if (jj_3R_12()) return true;
    return false;
  }

  static private boolean jj_3_2() {
    if (jj_3R_11()) return true;
    return false;
  }

  static private boolean jj_3R_11() {
    if (jj_scan_token(IDENTIFICADOR)) return true;
    if (jj_3R_16()) return true;
    return false;
  }

  static private boolean jj_3R_19() {
    if (jj_3R_21()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_22()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_33() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  static private boolean jj_3R_27() {
    if (jj_scan_token(MAS)) return true;
    return false;
  }

  static private boolean jj_3R_24() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_27()) {
    jj_scanpos = xsp;
    if (jj_3R_28()) return true;
    }
    return false;
  }

  static private boolean jj_3R_10() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_5()) {
    jj_scanpos = xsp;
    if (jj_3R_14()) {
    jj_scanpos = xsp;
    if (jj_3R_15()) return true;
    }
    }
    return false;
  }

  static private boolean jj_3_5() {
    if (jj_scan_token(VAR)) return true;
    if (jj_scan_token(IDENTIFICADOR)) return true;
    if (jj_scan_token(ASIGNACION)) return true;
    if (jj_scan_token(NEW)) return true;
    return false;
  }

  static private boolean jj_3R_32() {
    if (jj_scan_token(IDENTIFICADOR)) return true;
    return false;
  }

  static private boolean jj_3R_31() {
    if (jj_scan_token(PARENDRCHA)) return true;
    if (jj_3R_13()) return true;
    return false;
  }

  static private boolean jj_3R_29() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_31()) {
    jj_scanpos = xsp;
    if (jj_3R_32()) {
    jj_scanpos = xsp;
    if (jj_3R_33()) {
    jj_scanpos = xsp;
    if (jj_3R_34()) return true;
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_26() {
    if (jj_scan_token(CORCHETEDRCHA)) return true;
    return false;
  }

  static private boolean jj_3R_15() {
    if (jj_scan_token(IDENTIFICADOR)) return true;
    if (jj_scan_token(ASIGNACION)) return true;
    return false;
  }

  static private boolean jj_3R_25() {
    if (jj_3R_29()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_30()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_1() {
    if (jj_3R_10()) return true;
    return false;
  }

  static private boolean jj_3R_18() {
    if (jj_scan_token(INTERROGANTE)) return true;
    return false;
  }

  static private boolean jj_3R_17() {
    if (jj_3R_19()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_20()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_4() {
    if (jj_3R_13()) return true;
    return false;
  }

  static private boolean jj_3R_21() {
    if (jj_3R_23()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_24()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_30() {
    if (jj_3R_16()) return true;
    return false;
  }

  static private boolean jj_3R_20() {
    if (jj_scan_token(AND)) return true;
    return false;
  }

  static private boolean jj_3R_14() {
    if (jj_scan_token(VAR)) return true;
    if (jj_scan_token(IDENTIFICADOR)) return true;
    return false;
  }

  static private boolean jj_3R_12() {
    if (jj_scan_token(IDENTIFICADOR)) return true;
    if (jj_scan_token(CORCHETEDRCHA)) return true;
    if (jj_3R_13()) return true;
    return false;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public eg1TokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[25];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x1b38801,0x328800,0x1000000,0x1338800,0x0,0x0,0x9000000,0x1000000,0x0,0x0,0x0,0x1338800,0x0,0x1010000,0x0,0x0,0x0,0x0,0x0,0x0,0x39000000,0x20000000,0x0,0x39000000,0x39000000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x2,0x200,0x0,0x0,0x2,0x10,0x2,0x0,0x40,0x0,0x4000,0x200000,0x100,0x600,0x600,0x2,0x0,0x0,0x10,0x0,0x0,};
   }
  static final private JJCalls[] jj_2_rtns = new JJCalls[5];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  /** Constructor with InputStream. */
  public eg1(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public eg1(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new eg1TokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public eg1(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new eg1TokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public eg1(eg1TokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(eg1TokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  static final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[56];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 25; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 56; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  static private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 5; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  static private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
