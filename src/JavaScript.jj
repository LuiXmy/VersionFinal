/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */
options
{
  JDK_VERSION = "1.5";
  static = true;
  CHOICE_AMBIGUITY_CHECK = 4;
//  DEBUG_TOKEN_MANAGER=true;//DEBUGGEAR
}

PARSER_BEGIN(eg1)

import java.util.Vector;
import java.util.HashMap;
import java.util.LinkedList;
//A ver que sale ahora
public class eg1
{
	final static int ID = 24;
	final static int ENTERO = 27;
	final static int CADENA = 28;
	final static int FUNCION = 23;
	final static int VECTOR = 100;
  	static HashMap<String, TablaSimbolos> tablas = new HashMap <String, TablaSimbolos>();
	static TablaSimbolos tablageneral = new TablaSimbolos();
	static TablaSimbolos tablaactiva = tablageneral;
	static String nombrefuncion="";
	static LinkedList<tupla_Tercetos> lista = new LinkedList() ;
	
	private static class BloqueCondicion{
		String etqVerdad, etqFalso;
	}	

	private static void usarLabel(String label){
		System.out.println(label+":");
		Tercetos ter = new Tercetos();
 	    tupla_Tercetos tupla = new tupla_Tercetos(tablaactiva,ter.InsertarEtiqueta(label));
        lista.add(tupla);
	}
	
	private static void usarGoto(String label){
		System.out.println("\tgoto "+ label);
		Tercetos ter = new Tercetos();
 	    tupla_Tercetos tupla = new tupla_Tercetos(tablaactiva,ter.saltoIncondicional(label));
        lista.add(tupla);		
	}

	private static String OpRelacional(String e1,String e2,String op){
		String tmp = nuevaTmp();
		usarASIG(tmp, e1+op+e2);
		return tmp;
	}
	
	
//	private static BloqueCondicion usarOpRelacional(String e1,String e2,String op){
//		BloqueCondicion blq = new BloqueCondicion();
//		blq.etqVerdad = nuevaEtq();
//		blq.etqFalso = nuevaEtq();// habria que meter un temporal intermedio para gestionar e1+op+e2
//		String tmp=OpRelacional(e1,e2,op);
//		System.out.println("\tif "+ tmp +" goto "+ blq.etqVerdad);
//		usarGoto(blq.etqFalso);
//		return blq;
//	}




	private static void usarOpRelacional(BloqueCondicion blq, String op){
//		blq.etqVerdad = nuevaEtq();
		blq.etqFalso = nuevaEtq();// habria que meter un temporal intermedio para gestionar e1+op+e2
		System.out.println("\tif "+ op +" goto "+ blq.etqFalso);
		Tercetos ter = new Tercetos();
 	    tupla_Tercetos tupla = new tupla_Tercetos(tablaactiva,ter.saltoCondicional(op,blq.etqFalso));
        lista.add(tupla);
		
/*		System.out.println("\tif "+ op +" goto "+ blq.etqVerdad);
		usarGoto(blq.etqFalso);
		return blq;
*/
	}

	private static void bloqueFuncion(Token t)
	{
		usarLabel(t.image);
//		System.out.println("\tFUNCION "+t.image);
	}

	private static void imprimirLlamada(String nombre, Vector< Expresion > elementos)
	{
		for (int i=elementos.size()-1; i>=0; i--)
		{
				Expresion exp=elementos.get(i);
				System.out.println("\tparam "+ exp._str);
		}
		System.out.println("\tcall "+ nombre + ", "+elementos.size());
	}





	public static void usarOpInterrog(String op, String expr1, String expr2, String nombre){
		String etiqueta1=nuevaEtq();// etqFalso
		String etiqueta2=nuevaEtq();
		System.out.println("\tif "+ op +" goto "+ etiqueta1); // si no se cumple salto a etqFalso
		Tercetos ter = new Tercetos();
 	    tupla_Tercetos tupla = new tupla_Tercetos(tablaactiva,ter.saltoCondicional(op,etiqueta1));
        lista.add(tupla);
		usarASIG(nombre,expr1);
		usarGoto(etiqueta2);
		usarLabel(etiqueta1);
		usarASIG(nombre,expr2);
		usarLabel(etiqueta2);
	}
	

	private static void condicionDo(String etiq, String op){
		System.out.println("\tif "+ op +" goto "+ etiq);
	}
	
	private static void intercambiarCondicion(BloqueCondicion blq){
		String aux = blq.etqVerdad;
		blq.etqVerdad = blq.etqFalso;
		blq.etqFalso = blq.etqVerdad;
	}

	private static int actualTmp=0, actualEtq=0;

	private static String nuevaEtq(){
		return "etq"+(++actualEtq);
	}


	private static String nuevaTmp(){
		return "tmp"+(++actualTmp);
	}

	private static void usarASIG(String s, String e){
 	    System.out.println("\t"+s+"="+e);
 	    Tercetos ter = new Tercetos();
 	    tupla_Tercetos tupla = new tupla_Tercetos(tablaactiva,ter.asignacion(s,e));
        lista.add(tupla);
	}

	private static String usarOpUnario(String e1){
		String tmp = nuevaTmp();
		Symbol simbolo = new Symbol(tmp, 1234, ENTERO, 1);  // Tamaño incrustado
		tablaactiva.insertarTS(tmp,simbolo);
		System.out.println("\t"+tmp+"="+e1);
		Tercetos ter = new Tercetos();
        tupla_Tercetos tupla = new tupla_Tercetos(tablaactiva,ter.asignacion_valor(tmp,Integer.parseInt(e1)));
        lista.add(tupla);
		return tmp;
	}


	private static String usarOpAritmetico(String e1, String e2, String op){
		String tmp = nuevaTmp();
		Symbol simbolo = new Symbol(tmp, 1234, ENTERO,1);  // Tamaño incrustado
		tablaactiva.insertarTS(tmp,simbolo);
		System.out.println("\t"+tmp+"="+e1+op+e2);
		Tercetos ter = new Tercetos();
		tupla_Tercetos tupla = new tupla_Tercetos(tablaactiva,ter.operacionBinaria(e1,e2,op,tmp));
		lista.add(tupla);
		return tmp;
	}


	private static String usarOpRel(String e1, String e2, String op){
		String tmp = nuevaTmp();
		Symbol simbolo = new Symbol(tmp, 1234, ENTERO,1);  // Tamaño incrustado
		tablaactiva.insertarTS(tmp,simbolo);
		System.out.println("\t"+tmp+"="+e1+op+e2);
		Tercetos ter = new Tercetos();
		tupla_Tercetos tupla = new tupla_Tercetos(tablaactiva,ter.opRelacional(e1,e2,tmp));
		lista.add(tupla);
		return tmp;
	}


	private static String usarOpLogico(String e1, String e2, String op){
		String tmp = nuevaTmp();
		Symbol simbolo = new Symbol(tmp, 1234, ENTERO,1);  // Tamaño incrustado
		tablaactiva.insertarTS(tmp,simbolo);
		System.out.println("\t"+tmp+"="+e1+op+e2);
		Tercetos ter = new Tercetos();
		tupla_Tercetos tupla = new tupla_Tercetos(tablaactiva,ter.opLogico(e1,e2,tmp));
		lista.add(tupla);
		return tmp;
	}
	

	private static String operarVectorPrompt(String tmp, String nombreVector){
		String tmp2 = nuevaTmp();
		Symbol simbolo = new Symbol(tmp2, 1234, ENTERO);
		tablaactiva.insertarTS(tmp2,simbolo);
		System.out.println("\t"+tmp2+"="+nombreVector+"["+tmp+"]");
		return tmp2;
	}


	private static void copiarVectorEnOtro(Symbol tmp, Symbol tmp2)
	{
		for(int i=0; i<tmp.numeroelementos; i++)
		{
			System.out.println("\t"+tmp.key+"["+i+"]"+" = "+ tmp2.key+"["+i+"] ");	
		}
	}

	private static void asignacionVector(String id, int tamano, String exp, String exp1)
	{
		String etiq = nuevaEtq();
		System.out.println("\tif "+exp+" > " +tamano);
		System.out.println("\tgoto "+etiq);
		System.out.println("\t"+id+"["+exp+"]"+" = "+exp1);
		usarLabel(etiq);
	}


	
	private static boolean existeEnAlgunaTS(String clave)
	{
		if(!tablaactiva.existeClave(clave) && !tablageneral.existeClave(clave))
			return false;
		else
			return true;
	}
	
  	public static void main(String args []) throws ParseException
  	{
  	  
	    eg1 parser;// = new eg1(System.in);
          	if(args.length == 0){// ejecucion sin argumentos
        	System.out.println ("ExampleParser: Leyendo de la entrada estandar ...");
        	parser = new eg1(System.in);
      	}else if(args.length == 1){// ejecucion con fichero de entrada
	        System.out.println ("ExampleParser: Leyendo el fichero " + args[0]);
	        tablas.put("general",tablageneral);
        	try {
          	parser = new eg1(new java.io.FileInputStream(args[0]));
        	}
        	catch(java.io.FileNotFoundException e) {
          	System.out.println ("ExampleParser: El fichero " + args[0] + " no ha sido encontrado.");
          	return;
        	}
      	}else {// en otro caso
        	System.out.println ("ExampleParser:  Debes utilizarlo de una de las siguientes formas:");
        	System.out.println ("         java ExampleParser < fichero");
        	System.out.println ("Or");
        	System.out.println ("         java ExampleParser fichero");
        	return;
      	}
    	//  String linea;
    	boolean cond = true;
    	while (cond)
    	{
      	if (args.length == 1)
      			System.out.println("Leyendo linea");
      	else
	      {
	      		System.out.println("Leyendo de teclado...");
	      		System.out.print("Enter an expression like \"1+(2+3)*4;\" :");
	     }
	      try
	      {
	      	switch (eg1.one_line())
	        {
	          case -1 : 
	          System.out.println("Fin fichero"); // fin fichero
	          cond = false;
	          break;
	          case 0 : 
	          System.out.println("OK.");
	          break;
	          case 1 : 
	          System.out.println("OK. Funcion");
	          break;
	          case 2 : 
	          System.out.println("Ok. Sentencia");
	          break;
	          default : 
	          break;
	        }
	      }
	      catch (Exception e)
	      {
	        System.out.println("NOK.");
	        System.out.println(e.getMessage());
	        eg1.ReInit(System.in);
	      }
	      catch (Error e)
	      {
	        System.out.println("Oops.");
	        System.out.println(e.getMessage());
	        break;
	      }
	    }
	    System.out.println(lista.size());
	    tablageneral.imprimir();
		GenCodFinal codFinal = new GenCodFinal(lista,tablageneral,"ensamblador.ens");
	 }
}

PARSER_END(eg1)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| "/*": COMENTARIOS // mas de una linea de comentarios
|  "//": COMENTARIOS_UNA_LINEA
}

 // si aparece */ en COMENTARIOS se obvian y se vuelve al estado DEFAULT
< COMENTARIOS > SKIP : {
  "*/": DEFAULT
}
< COMENTARIOS > MORE : // probar en lugar de SKIP poner MORE
{
<  ~[] > // cualquier caracter que aparezca despues de /* no se tiene en cuenta
}

< COMENTARIOS_UNA_LINEA > SKIP : // comentarios de una linea
{
//  <( "\n" | "--" )> : DEFAULT
  "\n" : DEFAULT
}

< COMENTARIOS_UNA_LINEA > MORE : // probar en lugar de SKIP poner MORE
{
<  ~[] > // cualquier caracter que aparezca despues de // no se tiene en cuenta
}

TOKEN :
{
  < DO: "do" >
| < WHILE: "while" >
| < TRUE: "true" >
| < FALSE: "false" >
| < IF: "if" >
| < VAR: "var" >
| < RETURN: "return" >
| < NEW: "new" >
| < ARRAY: "Array" >
| < PROMPT: "prompt" >
| < DOCUMENT: "document" >
| < WRITE: "write" >
| < FUNCTION: "function" >
}

/* IDENTIFICADORES */

TOKEN :
{
  < IDENTIFICADOR: <LETRA> (<LETRA>|<DIGITO>|"_")* > //  Token.kind = 24
|
  < #LETRA:
      [ "a" - "z", "A" - "Z", "ñ", "Ñ" ] 
  >
|
  < #DIGITO: [ "0"-"9" ]
  >
}

/* CONSTANTES */

TOKEN :
{
  < INTEGER_LITERAL: (<DIGITO>)+ >  // el mayor entero puede ser XXXX. Token.kind = 27
| < STRING_LITERAL: "\"" ( ~["\"","\\","\n","\r"] | "\\" ( ["n","t","0","\\","\'","\""] | ( ["\n","\r"] | "\r\n")))* "\""> 
}

/* SEPARADORES */

TOKEN :
{
  < PARENDRCHA: "(" >
| < PARENIZQ: ")" >
| < LLAVEDRCHA: "{" >
| < LLAVEIZQ: "}" >
| < CORCHETEDRCHA: "[" >
| < CORCHETEIZQ: "]" >
| < PUNTOYCOMA: ";" >
| < COMA: "," >
| < PUNTO: "." >
}

TOKEN :
{
  < ASIGNACION: "=" >
| < MAYOR: ">" >
| < MENOR: "<" >
| < MAS: "+" >
| < MENOS: "-" >
| < MUL: "*" >
| < DIV: "/" >
| < MODULO: "%" >
| < INTERROGANTE: "?" >
| < DOSPUNTOS: ":" >
| < IGUAL: "==" >
| < MENORIGUAL: "<=" >
| < MAYORIGUAL: ">=" >
| < DISTINTO: "!=" >
| < OR: "||" >
| < AND: "&&" >
| < INC: "++" >
| < DEC: "--" >

}
//////////////

int one_line() : // punto de entrada del analizador sintactico
{}
{
		Funcion()
	{
		return 1;
	}
 	|
 	   Sentencia()
 	{
 		return 2;
 	}
 	|	< EOF >
	{
  		return -1;
	}
}


void Sentencia() :
{

}
{
   (
    LOOKAHEAD(2) VariableDeclarator()  // declaracion de variables y vectores
      |
	IfStatement()
      |
    DoStatement()
      |
    ReturnStatement()
      |
    PromptStatement()
      |
	DocumentStatement()
	  |
	LOOKAHEAD(2) FunctionStatement()
	  |
	LOOKAHEAD(3) VectorStatement()
	  |
	VectorAssignamentStatement()
   )
}

void VectorStatement() :
{
	Expresion exp=null;
	Expresion exp1=null;
	Token id;
	Symbol simbolo=null;
}
{
  id=< IDENTIFICADOR > "[" exp=Expresion(id.image) "]" < ASIGNACION > exp1=Expresion("")
  {
  		simbolo=tablaactiva.obtenerSimbolo(id.image);
  		if (simbolo==null)
  		{
  			simbolo=tablageneral.obtenerSimbolo(id.image);
  			if(simbolo==null)	
  				throw new Error("El Vector tiene que estar declarado previamente");
  		}
  		if (simbolo.tipo!=VECTOR)
  		{
  			throw new Error("El tipo del elemento izquierdo de la asignacion tiene que ser un vector");
  		}
  		if (exp._tipo!=ENTERO)
  		{
  			if (tablaactiva.tipo(exp._str)!=ENTERO) //Aqui es un ID
  			{
  				if (tablageneral.tipo(exp._str)!=ENTERO)
  				{
  					throw new Error("El tipo del indice del Vector debe ser un entero");
  				}
  			}
  		}  		
		if ((tablaactiva.existeClave(id.image) && tablaactiva.tipo(id.image)==VECTOR) ||
		(tablageneral.existeClave(id.image) && tablageneral.tipo(id.image)==VECTOR))
		{
			asignacionVector(simbolo.key, simbolo.numeroelementos, exp._str, exp1._str);
		}else
			throw new Error("El Vector en linea "+id.beginLine+" no existe");
  }
}

void VectorAssignamentStatement() :
{
	Token t=null;
	Token t2=null;
	Symbol aux=null;
	Symbol aux2=null;
}
{
   t=< IDENTIFICADOR > "[" "]" < ASIGNACION > t2=< IDENTIFICADOR > "[" "]"
   {
   		if(!existeEnAlgunaTS(t.image))
   		{
   			throw new Error("El vector izquierdo tiene que declararse antes de usarse");
   		}
   		if(!existeEnAlgunaTS(t2.image))
   		{
   			throw new Error("El vector derecho tiene que declararse antes de usarse");
   		}
   		if((tablaactiva.tipo(t.image)!=VECTOR || tablaactiva.tipo(t2.image)!=VECTOR))
   		{
   			throw new Error("El tipo de los dos operandos tiene que ser Vector");
   		}
   		if((tablageneral.tipo(t.image)!=VECTOR || tablageneral.tipo(t2.image)!=VECTOR))
   		{
   			throw new Error("El tipo de los dos operandos tiene que ser Vector");
   		}
   		aux=tablaactiva.obtenerSimbolo(t.image);
   		aux2=tablaactiva.obtenerSimbolo(t2.image);
   		if(aux==null)
   		{
   			tablageneral.obtenerSimbolo(t.image);
   		}
   		if(aux2==null)
   		{
   			tablageneral.obtenerSimbolo(t2.image);
   		}
   		if(aux.numeroelementos!=aux2.numeroelementos)
   		{
   			throw new Error("El tamaño de los dos vectores tiene que ser el mismo");
   		}
   		copiarVectorEnOtro(aux, aux2);
   }
}

void FunctionStatement() :
{
	Token tok;
  	Vector< Expresion > elementos=null;
  	Vector< Symbol > vdecl=null;
  	Symbol declfun=null;
}
{
  tok=< IDENTIFICADOR > elementos=LlamadaFuncion(tok)
  {
 		declfun=tablageneral.obtenerSimbolo(tok.image);
 		vdecl=declfun.vArgumentos;
 		for (int i=0; i<vdecl.size(); i++)
 		{
 			Expresion aux=elementos.get(i);
			if (vdecl.get(i).tipo != tablaactiva.obtenerSimbolo(aux._str).tipo)
				throw new Error("El tipo de los parametros de llamada no coincide con los de la declaracion");
 		}
 		imprimirLlamada(tok.image,elementos);
  }
}

void IfStatement() :
{
	Expresion expr = null;
	String etqFinIf = "";
	BloqueCondicion blq = new BloqueCondicion();
}
{

  < IF > expr = Expresion("") {
									usarOpRelacional(blq, expr._str);
    								//usarLabel(blq.etqVerdad);

    						}  Sentencia() {
									usarLabel(blq.etqFalso); 
							}
}

void DoStatement() :
{
	Expresion expr=null;
	String etq=null;
	BloqueCondicion blq = new BloqueCondicion();
}
{
  < DO > "{"
  {
  		etq=nuevaEtq();
  		usarLabel(etq);
  }
   (Sentencia())* "}" < WHILE > expr=Expresion("")
  {
  		condicionDo(etq,expr._str);
  }
}

void ReturnStatement() :
{
		Expresion exp=null;
}
{
        < RETURN > (LOOKAHEAD(2) exp=Expresion("")
        {
        	System.out.println(exp);
        })?
        {
        	System.out.println("RET");
        }
        

}

// prompt solo lee numeros del teclado, si se mete un caracter habria que lanzar un error en el tiempo de ejecucion, no se si eso podemos hacerlo
void PromptStatement() :
{
	Token t=null;
	boolean esVector = false;
	Symbol simbolo=null;
}
{
    < PROMPT > "(" t =	< IDENTIFICADOR >  // hay que comprobar si el identificador existe en tabla activa
    									   // por si el prompt esta dentro de una funcion
    									   // y si no existe en tabla activa mirar en tabla general, si no esta en ningún lado
    									   // es "variable no declarada" con lo cual se introduce en TS general como variable global
    									   // pero hay una movida, si la variable es nueva y en el siguiente paso vemos que es un vector
    									   // tenemos que dar un error, en el caso de tener aquí un vector tendría que estar declarado antes
    									   // dado que lo que se requiere en el prompt es una de las posiciones del vector y no el vector entero.
	   (esVector=PromptVector(esVector, t.image)
       {
          if (esVector)//Si estamos en el ambito general, error
    	  {
    	  	if (!tablaactiva.existeClave(t.image) || tablaactiva.tipo(t.image)!=VECTOR) // compruebo primero si existe ID en TS activa. no hace falta comprobar si tablaactiva==tablageneral
			{
		   		if (!tablageneral.existeClave(t.image) || tablaactiva.tipo(t.image)!=VECTOR) // compruebo despues si existe ID en TS general. si no existe se agrega a TS general
		   		{
    	    		throw new Error("Error. El identificador de vector no ha sido declarado previamente o no es el tipo correcto, linea: "+t.beginLine);
				}
			}
    	  }
       }
       )?
       {
			if (!tablaactiva.existeClave(t.image)) // compruebo primero si existe ID en TS activa. no hace falta comprobar si tablaactiva==tablageneral
			{
		   		if (!tablageneral.existeClave(t.image)) // compruebo despues si existe ID en TS general. si no existe se agrega a TS general
		   		{
    	    		simbolo=new Symbol(t.image, t.beginLine, ENTERO); // agrego nuevo simbolo a TS general
    	    		tablageneral.insertarTS(t.image, simbolo);
				}
			}
		}")"
}

// esto hay que mirarlo con cuidado es como las expresiones, habra que crear clase JSPromptAditiveExpresion y JSPromptVector
boolean PromptVector(boolean esVector,String nombreVector) :
{
	Expresion res;
}
{
 "["
 	{
 		esVector=true;
	}
 	res=PromptAditiveExpresion() "]"
  	{
  		operarVectorPrompt(res._str, nombreVector);
  		return esVector;
  	}
}

Expresion PromptAditiveExpresion() :
{
  Expresion st1 = null;
  Expresion st2 = null;
}
{// aqui dentro hay que comprobar los token, si es identificador tiene que existir en TS (primero comprobar tabla activa y luego general)
 // si no existe en ninguna TS generar error.
 // mas adelante habrá que comprobar si el indice del vector se encuentra dentro del rango del vector etc, etc.
 // para hacer las comprobaciones de los distintos tipos de Token usar t.kind, un integer es 27 y un identificador 24
	st1 = PromptPrimaryExpression()
	{
		if (st1._tipo == ID && !tablaactiva.existeClave(st1._str)) // compruebo primero si existe ID en TS activa. no hace falta comprobar si tablaactiva==tablageneral
		{
			if (!tablageneral.existeClave(st1._str)) // compruebo despues si existe ID en TS general. si no existe se agrega a TS general
			{
				throw new Error("Error. La variable "+st1._str+" en la linea "+st1._linea+" no ha sido declarada previamente.");
			}
		}// si el token es identificador, habra que poner el tipo del simbolo a ENTERO, si es de otro tipo se cambia y si es entero tb
//aqui habrá que hacer algo si el token es un numero
	}
	(< MAS >  st2 = PromptPrimaryExpression()
	{
		if (st2._tipo == ID && !tablaactiva.existeClave(st2._str)) // compruebo primero si existe ID en TS activa. no hace falta comprobar si tablaactiva==tablageneral
		{
			 if (!tablageneral.existeClave(st2._str)) // compruebo despues si existe ID en TS general. si no existe se agrega a TS general
			{
    			throw new Error("Error. La variable "+st2._str+" en la linea "+st2._linea+" no ha sido declarada previamente.");
			}
		}
		if(st1._tipo==ENTERO && st2._tipo==ENTERO)
		{
			st1._str = usarOpAritmetico(st1._str, st2._str, "+");
		}else if(tablaactiva.tipo(st1._str)==ENTERO && tablaactiva.tipo(st2._str)==ENTERO)
		{
			st1._str = usarOpAritmetico(st1._str, st2._str, "+");
		}else
		{
			throw new Error("El tipo de las expresiones no es correcto");
		}
	}
	)?
	{
			return st1;
	}
}

Expresion PromptPrimaryExpression() :
{
	Token t = null;
	Expresion st = null;
}
{
  (
    t = <IDENTIFICADOR>
    {
    	st = new Expresion(t.image, t.kind, t.beginLine);
   		st.t = t;
   	} 
  |
    t = <INTEGER_LITERAL>
    {
    	st = new Expresion(usarOpAritmetico(token.image, "", ""), t.kind, t.beginLine);
    }
  )
  {
     return st;
  }
}



void DocumentStatement() :
{
	Expresion expr=null;
}
{
    < DOCUMENT > < PUNTO > < WRITE > "(" expr=Expresion("") ")"
    {
    		System.out.println("\timprime "+ expr._str);
    }
}


void Funcion() : //Declaracion de funciones
{
	Token t=null;
	Vector< Symbol > vectorSimbolos=null;
	Symbol simbolo=null;
	int numeroParametros=0;
}
{
   < FUNCTION > t=<IDENTIFICADOR>
   {
   		nombrefuncion=t.image;
		if(tablageneral.existeClave(t.image))
		{
			throw new Error("Error en la linea "+t.beginLine+": Identificador de funcion ya declarado");
		}else
		{
			simbolo=new Symbol(t.image, t.beginLine, FUNCION );
		}
		bloqueFuncion(t);
   }"("
   {
   		tablaactiva = new TablaSimbolos(tablageneral);
   		tablas.put(nombrefuncion, tablaactiva);
   		//No hace falta comparar si ya estaba el nombre de la funcion en la lista de tablas
   		//porque lo contemplo antes
   }
   ( vectorSimbolos=ParameterList()
   {
   		numeroParametros=vectorSimbolos.size();
   })?
    ")"
    {
    	simbolo.numArgumentos=numeroParametros;
    	simbolo.vArgumentos=vectorSimbolos;
    	tablageneral.insertarTS(t.image, simbolo);
    }CompoundStatement()
   {
   		System.out.println("La tabla de la funcion tiene: ");
   		//tablaactiva.imprimir();
   		//tablageneral.imprimir();
   		tablaactiva = tablas.get("general");
   }
}

Vector ParameterList() : // lista de parametros para la definicion de la funcion
{
	Vector< Symbol > v = new Vector < Symbol >();
	Symbol simbolo = null;
	boolean esVector=false;
	Token parametro;
}
{
    parametro=<IDENTIFICADOR> ("[" "]"
    {//Tenemos un vector
    	esVector=true;
    }
    )?
    {
    	if(esVector)
    	{
    		simbolo = new Symbol(parametro.image, parametro.beginLine, VECTOR);//He metido el tipo 100 como vector
    		tablaactiva.insertarTS(parametro.image,simbolo);
    		v.add(simbolo);
    	}else
    	{
    		simbolo = new Symbol(parametro.image, parametro.beginLine, ENTERO);
			tablaactiva.insertarTS(parametro.image,simbolo);
			v.add(simbolo);
    	}
    	esVector=false;
    }
    ("," parametro=<IDENTIFICADOR> ("[" "]"
    {
    	esVector=true;
    })?
    {
    	if(esVector)
    	{
    		simbolo = new Symbol(parametro.image, parametro.beginLine, VECTOR);
    		tablaactiva.insertarTS(parametro.image,simbolo);
    		v.add(simbolo);
    	}else
    	{
    		simbolo = new Symbol(parametro.image, parametro.beginLine, ENTERO);
			tablaactiva.insertarTS(parametro.image,simbolo);
			v.add(simbolo);
    	}
    	esVector=false;
    })*
    {
    		return v;
    }
}


void CompoundStatement() :
{
}
{
  "{" (Sentencia())* "}"
}


//este hace las asignaciones
void VariableDeclarator() :
{
	Token t = null;
	Expresion expr = null;
	Symbol simbolo=null;
	Token elementos =null;
	int num;
}
{
     LOOKAHEAD(4) < VAR > t=< IDENTIFICADOR > < ASIGNACION >  < NEW > < ARRAY > "(" elementos=< INTEGER_LITERAL > ")"
     {
     		num=Integer.parseInt(elementos.image);
//			}catch (java.lang.NumberFormatException exc){
//				throw new Error("El Indice del Vector declarado en la linea "+t.beginLine+" tiene que ser un entero");
//			}
			if (num<=0)
			{
				throw new Error("El numero de elementos del Vector declarado en linea "+t.beginLine+" tiene que ser mayor que cero");
			}
			//Symbol(String key, int numerolinea, int tipo, int tamano, int numeroelementos) {
     		simbolo = new Symbol(t.image, t.beginLine, VECTOR, num*4, num);
     
     		simbolo.numeroelementos=num;
     		tablaactiva.insertarTS(t.image, simbolo);
     		//tablaactiva.imprimir();
     }
  | 
     < VAR > t = < IDENTIFICADOR >
     	{
     		simbolo=new Symbol(t.image, t.beginLine, ENTERO);
     		tablaactiva.insertarTS(t.image, simbolo);
     	}
     	(< ASIGNACION > expr = Expresion(t.image)
     	{
			usarASIG(t.image, expr._str);
		})?
  |
		t = < IDENTIFICADOR >
					{// no estabamos metiendo este identificador en la TS
					// creo que habria que mirar primero si está en la tabla, si no no se inserta, seguramente haya que com
						if(!existeEnAlgunaTS(t.image))						{
						  	simbolo=new Symbol(t.image, t.beginLine, ENTERO);
     						tablaactiva.insertarTS(t.image, simbolo);
     					}
     				}

			< ASIGNACION > expr = Expresion(t.image)
   		{
   				if(expr._str!="")
   				{
   						
   					if (!tablaactiva.buscar(t.image) && !tablageneral.buscar(t.image))
   					{
   						simbolo = new Symbol(t.image, t.beginLine, ENTERO);
   						tablageneral.insertarTS(t.image, simbolo);
   				}
   				//Esto hay que arreglarlo
   				System.out.println("\t"+t.image+"="+expr._str+"; asignacionVariable");
   				usarASIG(t.image,expr._str);
   				}
   		}

}

Expresion Expresion(String variable) :
{
  	Expresion expr=null;
  	Expresion expr2=null;
  	Expresion expr3=null;
  	Expresion expr4=null;
	BloqueCondicion blq=new BloqueCondicion();
}
{
 expr = ExpresionAND() ("?" expr2=Expresion("") ":" expr3=Expresion("")
 	{
 		usarOpInterrog(expr._str,expr2._str,expr3._str, variable);
 		expr4=new Expresion("",ENTERO);
 		return expr4;
 	})?
    {
       return expr;
    }
}


Expresion ExpresionAND() :
{
  	Expresion expr1 = null;
  	Expresion expr2 = null;
}
{
  expr1 = RelationalExpression() ( "&&" expr2 = RelationalExpression(){
															expr1._str = usarOpLogico(expr1._str, expr2._str, "&&"); })*
    {
    	return expr1;
    }
}

Expresion RelationalExpression() :
{
	boolean expr1TablaActiva = false;
	boolean expr2TablaActiva = false;
	boolean expr1TablaGeneral = false;
	boolean expr2TablaGeneral = false;
  	Expresion expr1 = null;
  	Expresion expr2 = null;
  	Expresion exprCond = null;
  	BloqueCondicion blqCond;
//  String st = "";
}
{
  //revisar, en la version de luis hay JSRelacional(t, expr1, expr2);  pero expr1 no se le ha asignado ningún valor
  expr1 = AdditiveExpression()
  	(< MENOR > expr2 = AdditiveExpression()
  		{

		if(tablaactiva.tipo(expr1._str)!=-1)
			expr1TablaActiva = true;
		else if(tablageneral.tipo(expr1._str)!=-1)
			expr1TablaGeneral = true;
		if(tablaactiva.tipo(expr2._str)!=-1)
			expr2TablaActiva = true;
		else if(tablageneral.tipo(expr2._str)!=-1)
			expr2TablaGeneral = true;
	
		if(expr1._tipo==ENTERO && expr2._tipo==ENTERO)
		{
			expr1._str = usarOpAritmetico(expr1._str, expr2._str, "+");
		}else if((tablaactiva.tipo(expr1._str)==ENTERO&&expr1TablaActiva) &&
		         (tablaactiva.tipo(expr2._str)==ENTERO&&expr2TablaActiva))
		{
			expr1._str = usarOpAritmetico(expr1._str, expr2._str, "+");
		}else if((tablageneral.tipo(expr1._str)==ENTERO&&expr1TablaGeneral) &&
		         (tablaactiva.tipo(expr2._str)==ENTERO&&expr2TablaActiva))
		{
			expr1._str = usarOpAritmetico(expr1._str, expr2._str, "+");
		}else if((tablaactiva.tipo(expr1._str)==ENTERO&&expr1TablaActiva) &&
		         (tablageneral.tipo(expr2._str)==ENTERO&&expr2TablaGeneral))
		{
			expr1._str = usarOpAritmetico(expr1._str, expr2._str, "+");
		}else if((tablageneral.tipo(expr1._str)==ENTERO&&expr1TablaGeneral) &&
		         (tablageneral.tipo(expr2._str)==ENTERO&&expr2TablaGeneral))
		{
			expr1._str = usarOpAritmetico(expr1._str, expr2._str, "+");
		}else
		{
			throw new Error("El tipo de las expresiones no es correcto");
		}
	}	)*
    {
      return expr1;
    }
}

Expresion AdditiveExpression() :
{
	boolean expr1TablaActiva = false;
	boolean expr2TablaActiva = false;
	boolean expr1TablaGeneral = false;
	boolean expr2TablaGeneral = false;
  	Expresion expr1 = null;
  	Expresion expr2 = null;
	String st1 = "";
  	String st2 = "";
}
{
	expr1 = VectorExpression() (< MAS > expr2 = VectorExpression()
	{

		if(tablaactiva.tipo(expr1._str)!=-1)
			expr1TablaActiva = true;
		else if(tablageneral.tipo(expr1._str)!=-1)
			expr1TablaGeneral = true;
		if(tablaactiva.tipo(expr2._str)!=-1)
			expr2TablaActiva = true;
		else if(tablageneral.tipo(expr2._str)!=-1)
			expr2TablaGeneral = true;
	
		if(expr1._tipo==ENTERO && expr2._tipo==ENTERO)
		{
			expr1._str = usarOpAritmetico(expr1._str, expr2._str, "+");
		}else if((tablaactiva.tipo(expr1._str)==ENTERO&&expr1TablaActiva) &&
		         (tablaactiva.tipo(expr2._str)==ENTERO&&expr2TablaActiva))
		{
			expr1._str = usarOpAritmetico(expr1._str, expr2._str, "+");
		}else if((tablageneral.tipo(expr1._str)==ENTERO&&expr1TablaGeneral) &&
		         (tablaactiva.tipo(expr2._str)==ENTERO&&expr2TablaActiva))
		{
			expr1._str = usarOpAritmetico(expr1._str, expr2._str, "+");
		}else if((tablaactiva.tipo(expr1._str)==ENTERO&&expr1TablaActiva) &&
		         (tablageneral.tipo(expr2._str)==ENTERO&&expr2TablaGeneral))
		{
			expr1._str = usarOpAritmetico(expr1._str, expr2._str, "+");
		}else if((tablageneral.tipo(expr1._str)==ENTERO&&expr1TablaGeneral) &&
		         (tablageneral.tipo(expr2._str)==ENTERO&&expr2TablaGeneral))
		{
			expr1._str = usarOpAritmetico(expr1._str, expr2._str, "+");
		}else
		{
			throw new Error("El tipo de las expresiones no es correcto");
		}
	}
	|< MENOS > expr2 = VectorExpression()
	{
		if(tablaactiva.tipo(expr1._str)!=-1)
			expr1TablaActiva = true;
		else if(tablageneral.tipo(expr1._str)!=-1)
			expr1TablaGeneral = true;
		if(tablaactiva.tipo(expr2._str)!=-1)
			expr2TablaActiva = true;
		else if(tablageneral.tipo(expr2._str)!=-1)
			expr2TablaGeneral = true;
	
		if(expr1._tipo==ENTERO && expr2._tipo==ENTERO)
		{
			expr1._str = usarOpAritmetico(expr1._str, expr2._str, "-");
		}else if((tablaactiva.tipo(expr1._str)==ENTERO&&expr1TablaActiva) &&
		         (tablaactiva.tipo(expr2._str)==ENTERO&&expr2TablaActiva))
		{
			expr1._str = usarOpAritmetico(expr1._str, expr2._str, "-");
		}else if((tablageneral.tipo(expr1._str)==ENTERO&&expr1TablaGeneral) &&
		         (tablaactiva.tipo(expr2._str)==ENTERO&&expr2TablaActiva))
		{
			expr1._str = usarOpAritmetico(expr1._str, expr2._str, "-");
		}else if((tablaactiva.tipo(expr1._str)==ENTERO&&expr1TablaActiva) &&
		         (tablageneral.tipo(expr2._str)==ENTERO&&expr2TablaGeneral))
		{
			expr1._str = usarOpAritmetico(expr1._str, expr2._str, "-");
		}else if((tablageneral.tipo(expr1._str)==ENTERO&&expr1TablaGeneral) &&
		         (tablageneral.tipo(expr2._str)==ENTERO&&expr2TablaGeneral))
		{
			expr1._str = usarOpAritmetico(expr1._str, expr2._str, "-");
		}else
		{
			throw new Error("El tipo de las expresiones no es correcto");
		}
	})*
    {
    	return expr1;
    }
}

Expresion VectorExpression() :
{
	Expresion expr = null;
  	Expresion expr2 = null;
  	Symbol simbolo=null;
  	Token t=null;
}
{

	expr = FunctionExpression() (t="[" (expr2=Expresion(""))? "]"
	{
		String tmp=nuevaTmp();
		if(expr2!=null)
		{
			System.out.println("\t"+tmp+" = "+expr._str+ "[ "+expr2._str+" ]");
			simbolo=new Symbol(tmp, t.beginLine, ENTERO);
			tablaactiva.insertarTS(tmp,simbolo);
			Expresion resultado = new Expresion(tmp, ENTERO);
			return  resultado;
		}
		
	}
	)*
	{
		return expr;
	}
}

Expresion FunctionExpression() :
{
  Expresion expr = null;
  Vector< Expresion > v;
  Vector< Symbol > vdecl;
  Symbol declfun=null;
}
{
	expr = PrimaryExpression() (v=LlamadaFuncion(expr.t)
    {
 		declfun=tablageneral.obtenerSimbolo(expr.t.image);
 		vdecl=declfun.vArgumentos;
 		for (int i=0; i<vdecl.size(); i++)
 		{
			Expresion aux=v.get(i);
			if (vdecl.get(i).tipo != tablaactiva.obtenerSimbolo(aux._str).tipo)
				throw new Error("El tipo de los parametros de llamada no coincide con los de la declaracion");
 		}
 		imprimirLlamada(expr._str,v);
 		return expr;
 	})*
 	
   	{
   		return expr;
   	}
}

Vector LlamadaFuncion(Token nombre) : //Solo se la llama desde functionexpresion
{
	Vector v = null;
}
{
   "("
		   {
		   		//tablageneral.imprimir();
   				if ((nombre.kind==ID) && (tablageneral.tipo(nombre.image) != FUNCION))
					throw new Error("La funcion no esta declarada anteriormente");				
		   }

		//Meter aqui lo que viene de llamadafuncion()

   v=ArgumentList(nombre) ")"
   {
   		return v;
   }
}

Vector ArgumentList(Token nombre) : // lista de argumentos para una llamada a funcion
									//Comprobar que los vectores están declarados antes
									//Los ID tambien
{
  	Token t=null;
	Expresion expr1=null;
	Expresion expr2=null;
	Vector< Expresion >v = null;
	Symbol temp=null;
}
{
  {
  		
  }
  (expr1 = Expresion("")
  {
  		v=new Vector < Expresion >();
  		
  		if (existeEnAlgunaTS(expr1._str))
  		{
  			v.add(expr1);
  		}else
  		{
  			throw new Error("Error en linea: "+nombre.beginLine+", Los parametros tienen que ser declarados antes de usarlos");
  		}
  } ("," expr2 =  Expresion("")
  {
  		if(existeEnAlgunaTS(expr1._str))
  		{
  			v.add(expr2);
  		}else
  		{
  			throw new Error("Error en linea: "+nombre.beginLine+" Los parametros tienen que ser declarados antes de usarlos");
  		}
  }
  )*)?
  {
  		temp = tablageneral.obtenerSimbolo(nombre.image);
		if(v==null && temp.numArgumentos == 0)
		{
			return null;
		}
		if(v==null)
		{
				v=new Vector < Expresion >();
		}
  		if(temp.numArgumentos!=v.size())
  		{
  			throw new Error("Numero de argumentos de la llamada a funcion en "+nombre.beginLine+" no coincide con los de la declaración");
  			
  		}
		else
  		    return v;
  }
}



Expresion PrimaryExpression() :
{
 Token t = null;
 Expresion st = null;
}
{
  (
    "(" st = Expresion("")")"

  |
   t = <IDENTIFICADOR> {st = new Expresion(t.image, t.kind);
   							st.t = t;}

  |
 //  t = <INTEGER_LITERAL> {st = new Expresion(usarOpAritmetico(token.image, "", ""), t.kind); }
   t = <INTEGER_LITERAL> {st = new Expresion(usarOpUnario(token.image), t.kind);

		if(Integer.parseInt(token.image) > 32767)		{				// al no usar operador unario no comprobamos limite inferior || Integer.parseInt(token.image) < -32768)
			throw new Error ("El numero esta fuera del rango de la maquina [-32768..32767]");
   		}

  |
   t = <STRING_LITERAL> {
		String cadena = t.image.substring(1, t.image.length()-1);
		try{
				int feo=Integer.parseInt(cadena);
				st = new Expresion(usarOpAritmetico(cadena, "", ""), ENTERO);
				return st; 
			}catch (java.lang.NumberFormatException exc){
				//throw new Error("El String a transformar tiene que ser un entero");
			}
		st = new Expresion(cadena, t.kind);
   		st.t = t;}

  )
 {return st;}
  
}